<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Planta Baixa - Segurança Eletrônica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&family=Roboto:wght@400;500;700&family=Source+Code+Pro:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --rs-dark-blue: #1a2e4f;
            --rs-green: #8bc53f;
        }
        body {
            font-family: 'Montserrat', sans-serif;
            touch-action: none; /* Previne zoom e pan do navegador em dispositivos touch */
        }
        #floorPlanCanvas {
            background-color: white;
            cursor: crosshair;
        }
        .tool-btn.active {
            background-color: var(--rs-green);
            color: var(--rs-dark-blue);
        }
        .tool-btn.active svg {
            stroke: var(--rs-dark-blue);
        }
        /* Esconde os controles por padrão */
        #textControls, #shapeControls, #nameControls, #doorWindowControls {
            display: none;
        }
        /* Custom color picker style */
        .color-picker-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }
        .color-picker-wrapper input[type="color"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        /* Custom scrollbar for mobile toolbar */
        aside::-webkit-scrollbar {
            height: 4px;
        }
        aside::-webkit-scrollbar-thumb {
            background-color: #4a5a78;
            border-radius: 10px;
        }
    </style>
</head>
<body class="bg-gray-200 flex flex-col h-screen overflow-hidden">

    <!-- Cabeçalho com Controles -->
    <header class="bg-[var(--rs-dark-blue)] text-white shadow-md p-2 flex items-center justify-between z-20 flex-wrap gap-2">
        <h1 class="text-lg lg:text-xl font-bold">Projeto de segurança</h1>
        <div class="flex items-center gap-2 lg:gap-4 flex-wrap justify-end">
             <!-- Controles de Nome de Objeto -->
            <div id="nameControls" class="items-center gap-2">
                <input type="text" id="objectNameInput" placeholder="Nome do Objeto" class="border bg-gray-100 text-black border-gray-300 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--rs-green)]">
            </div>
            <!-- Controles de Portas e Janelas -->
            <div id="doorWindowControls" class="items-center gap-2">
                <label for="doorWindowWidth" class="text-sm">Largura:</label>
                <input type="number" id="doorWindowWidth" min="20" max="200" step="5" class="border bg-gray-100 text-black border-gray-300 rounded-md px-2 py-1 text-sm w-20 focus:outline-none focus:ring-2 focus:ring-[var(--rs-green)]">
                <button id="flipBtn" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1.5 rounded-md text-sm font-bold flex items-center gap-2" title="Inverter Lado">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 2h- hücre-4v20h4v-20zM3 2v20h4V2H3z"/><path d="M21 12H7"/></svg>
                    Inverter
                </button>
            </div>
            <!-- Controles de Formas (visíveis quando uma forma é selecionada) -->
            <div id="shapeControls" class="items-center gap-3">
                <div class="color-picker-wrapper bg-white">
                    <span class="text-xs text-gray-600 pl-1">Borda:</span>
                    <div id="strokeColorPreview" class="w-5 h-5 rounded-sm border border-gray-300" style="background-color: #333;"></div>
                    <input type="color" id="strokeColorPicker" value="#333333">
                </div>
                 <div class="color-picker-wrapper bg-white">
                    <span class="text-xs text-gray-600 pl-1">Fundo:</span>
                    <div id="fillColorPreview" class="w-5 h-5 rounded-sm border border-gray-300" style="background-color: transparent;"></div>
                    <input type="color" id="fillColorPicker" value="#ffffff">
                </div>
            </div>
             <!-- Controles de Texto (visíveis quando um texto é selecionado) -->
            <div id="textControls" class="items-center gap-2">
                <select id="fontFamilySelect" class="border border-gray-300 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--rs-green)] text-black">
                    <option value="Montserrat">Montserrat</option>
                    <option value="Roboto">Roboto</option>
                    <option value="Source Code Pro">Source Code Pro</option>
                </select>
                <input type="number" id="fontSizeInput" value="16" min="8" max="120" class="border border-gray-300 rounded-md px-2 py-1 text-sm w-20 focus:outline-none focus:ring-2 focus:ring-[var(--rs-green)] text-black">
            </div>
            <div class="flex items-center gap-2">
                <button id="undoBtn" title="Desfazer (Ctrl+Z)" class="p-2 rounded-md bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 9"/></svg>
                </button>
                <button id="redoBtn" title="Refazer (Ctrl+Y)" class="p-2 rounded-md bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 3v6h-6"/><path d="M3 12A9 9 0 0 0 18 18.7L21 15"/></svg>
                </button>
            </div>

            <input type="text" id="projectName" value="Projeto Sem Título" class="border bg-gray-100 text-black border-gray-300 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--rs-green)]">
            <div class="flex items-center gap-2">
                <button id="portraitBtn" title="Orientação Retrato" class="p-2 rounded-md tool-btn active bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="2" width="12" height="20" rx="2" ry="2"></rect></svg>
                </button>
                <button id="landscapeBtn" title="Orientação Paisagem" class="p-2 rounded-md tool-btn bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2" ry="2"></rect></svg>
                </button>
            </div>
            <button id="downloadPdfBtn" class="bg-[var(--rs-green)] text-[var(--rs-dark-blue)] px-4 py-1.5 rounded-md hover:opacity-90 transition-opacity text-sm font-bold flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                Baixar PDF
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden flex-col lg:flex-row">
        <!-- Barra de Ferramentas -->
        <aside class="w-full lg:w-56 bg-[var(--rs-dark-blue)] text-white shadow-md flex flex-row lg:flex-col items-center lg:items-start p-2 lg:p-4 gap-4 lg:gap-2 z-10 overflow-x-auto lg:overflow-y-auto order-last lg:order-first">
            <h2 class="hidden lg:block text-sm font-bold text-gray-400 my-2 px-2 w-full">FERRAMENTAS</h2>
            <button id="selectTool" class="flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn active lg:w-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="m13 13 6 6"/></svg>
                <span class="text-xs lg:text-sm font-medium">Selecionar</span>
            </button>
            <button id="wallTool" class="flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L3 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><path d="m14.5 12.5 2-2"/><path d="m11.5 9.5 2-2"/><path d="m8.5 6.5 2-2"/><path d="m17.5 15.5 2-2"/></svg>
                <span class="text-xs lg:text-sm font-medium">Parede</span>
            </button>
            <button id="textTool" class="flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full">
                 <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15V6M3 15V6M3 15h18M3 6h18"/><path d="M12 6v15"/></svg>
                 <span class="text-xs lg:text-sm font-medium">Texto</span>
            </button>

            <div class="h-full lg:h-auto border-l lg:border-t border-gray-700 mx-2 my-0 lg:my-4 lg:mx-0 lg:w-full"></div>

            <h2 class="hidden lg:block text-sm font-bold text-gray-400 mb-2 px-2 w-full">FORMAS</h2>
            <button class="shape-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="rectangle">
                <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                <span class="text-xs lg:text-sm font-medium">Retângulo</span>
            </button>
            <button class="shape-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="circle">
                <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>
                <span class="text-xs lg:text-sm font-medium">Círculo</span>
            </button>
            <button class="shape-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="triangle">
                <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path></svg>
                <span class="text-xs lg:text-sm font-medium">Triângulo</span>
            </button>
            
            <div class="h-full lg:h-auto border-l lg:border-t border-gray-700 mx-2 my-0 lg:my-4 lg:mx-0 lg:w-full"></div>

            <h2 class="hidden lg:block text-sm font-bold text-gray-400 mb-2 px-2 w-full">ESTRUTURA</h2>
             <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="door">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#8d5b2d" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 20V6a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v14"/><path d="M2 20h20"/><path d="M14 12v.01"/></svg>
                <span class="text-xs lg:text-sm font-medium">Porta</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="window">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#38bdf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12h20"/><path d="M12 2v20"/><path d="M20 2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"/></svg>
                <span class="text-xs lg:text-sm font-medium">Janela</span>
            </button>

            <div class="h-full lg:h-auto border-l lg:border-t border-gray-700 mx-2 my-0 lg:my-4 lg:mx-0 lg:w-full"></div>

            <h2 class="hidden lg:block text-sm font-bold text-gray-400 mb-2 px-2 w-full">EQUIPAMENTOS</h2>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="camera">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="4" width="20" height="16" rx="2"/><circle cx="12" cy="12" r="4"/></svg>
                <span class="text-xs lg:text-sm font-medium">Câmera</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="motion_sensor">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15.5 12a3.5 3.5 0 0 0-3.5-3.5V6a6 6 0 0 1 6 6h-2.5Z"/><path d="M8.5 12a3.5 3.5 0 0 1 3.5 3.5V18a6 6 0 0 0-6-6h2.5Z"/><path d="m12 15.5 3.5-3.5"/><path d="M8.5 12 12 8.5"/></svg>
                 <span class="text-xs lg:text-sm font-medium text-center">S. Movim.</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="open_sensor">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2v4"/><path d="M16 2v4"/><rect width="18" height="16" x="3" y="6" rx="2"/><path d="M11 12h2"/></svg>
                 <span class="text-xs lg:text-sm font-medium text-center">S. Abert.</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="siren">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z"/><path d="M4.2 11.2C3 10 2 11 2 12.4v2.2c0 1.5 1.2 2.5 2.5 2.5h1.4c.5 0 .9.3 1.2.6l2.3 2.3c1.3 1.3 3.3.4 3.3-1.4v-6.6c0-1.8-2-2.7-3.3-1.4L8.1 11c-.3.3-.7.6-1.2.6H5.5C4.8 11.6 4.4 11.4 4.2 11.2z"/><path d="M18 8.7a4.2 4.2 0 0 1 0 6.6"/><path d="M20.5 6.2a8.5 8.5 0 0 1 0 11.6"/></svg>
                <span class="text-xs lg:text-sm font-medium">Sirene</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="dvr">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#a78bfa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="5" width="20" height="14" rx="2"/><path d="M12 12h.01"/><path d="M17 12h.01"/><path d="M7 12h.01"/></svg>
                <span class="text-xs lg:text-sm font-medium">DVR</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="alarm_panel">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fb923c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>
                <span class="text-xs lg:text-sm font-medium">Central Alarme</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="remote_control">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#22d3ee" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="2" width="8" height="20" rx="2"/><path d="M7 6v0"/><path d="M7 12v0"/><path d="M7 18v0"/></svg>
                <span class="text-xs lg:text-sm font-medium">C. Remoto</span>
            </button>
            <button class="object-btn flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn lg:w-full" data-type="keypad">
                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#facc15" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 8h.01"/><path d="M12 8h.01"/><path d="M17 8h.01"/><path d="M7 13h.01"/><path d="M12 13h.01"/><path d="M17 13h.01"/><path d="M7 18h.01"/><path d="M12 18h.01"/><path d="M17 18h.01"/></svg>
                 <span class="text-xs lg:text-sm font-medium">Teclado</span>
            </button>

             <div class="h-full lg:h-auto border-l lg:border-t border-gray-700 mx-2 my-0 lg:my-4 lg:mx-0 lg:w-full"></div>

             <button id="duplicateBtn" class="flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn hover:bg-blue-500 lg:w-full">
                 <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                 <span class="text-xs lg:text-sm font-medium">Duplicar</span>
            </button>
            <button id="deleteBtn" class="flex-shrink-0 flex flex-col lg:flex-row items-center gap-1 lg:gap-3 p-2 lg:px-2 lg:py-2 rounded-md tool-btn hover:bg-red-500 lg:w-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="text-white" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="m5 6 1 0 1-0"/><path d="M10 3v3h4V3"/></svg>
                <span class="text-xs lg:text-sm font-medium">Apagar</span>
            </button>
        </aside>

        <!-- Área do Canvas -->
        <main id="canvas-container" class="flex-1 bg-gray-300 flex items-center justify-center p-4 overflow-auto relative">
            <canvas id="floorPlanCanvas" class="shadow-lg"></canvas>
            <div id="zoom-controls" class="absolute bottom-28 lg:bottom-4 right-4 flex flex-col items-center gap-2">
                <button id="zoomInBtn" class="bg-[var(--rs-dark-blue)] text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg hover:bg-opacity-90">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </button>
                <div id="zoom-display" class="bg-[var(--rs-dark-blue)] text-white text-xs font-bold rounded-md px-2 py-1 shadow-lg">100%</div>
                <button id="zoomOutBtn" class="bg-[var(--rs-dark-blue)] text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg hover:bg-opacity-90">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                </button>
                 <button id="fitToScreenBtn" class="bg-[var(--rs-dark-blue)] text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg hover:bg-opacity-90 mt-2" title="Ajustar à Tela">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                </button>
            </div>
        </main>
    </div>
    
    <!-- Notificação -->
    <div id="notification" class="absolute top-5 right-5 bg-red-500 text-white px-4 py-2 rounded-md shadow-lg transition-transform transform translate-x-[120%] duration-300 z-50"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { jsPDF } = window.jspdf;
            const canvas = document.getElementById('floorPlanCanvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');
            const zoomDisplay = document.getElementById('zoom-display');

            // --- ESTADO DA APLICAÇÃO ---
            let state = {
                elements: [],
                selectedElementId: null,
                activeTool: 'select', // select, wall, add_object, text, shape
                objectToAdd: null,
                shapeToAdd: null,
                isDrawing: false,
                startPoint: { x: 0, y: 0 },
                pan: { x: 0, y: 0, active: false, start: {x: 0, y: 0} },
                zoom: 1,
                orientation: 'portrait', // portrait, landscape
                projectName: 'Projeto Sem Título',
                alignmentGuides: [],
                history: [],
                historyIndex: -1
            };

            const images = {};
            document.querySelectorAll('.object-btn').forEach(btn => {
                const img = new Image();
                const svgElement = btn.querySelector('svg');
                const coloredSvg = svgElement.cloneNode(true);
                coloredSvg.setAttribute('class', '');
                const svgString = new XMLSerializer().serializeToString(coloredSvg);
                const svgDataUrl = "data:image/svg+xml;base64," + btoa(svgString);
                img.src = svgDataUrl;
                images[btn.dataset.type] = img;
                img.onload = () => { draw(); };
            });
            
            const objectTitles = {};
            document.querySelectorAll('button[data-type]').forEach(btn => {
                const titleElement = btn.querySelector('span');
                if(titleElement) {
                    objectTitles[btn.dataset.type] = titleElement.textContent.trim();
                }
            });

            // --- FUNÇÕES DE RENDERIZAÇÃO ---
            function drawScene(targetCtx, elementsToDraw) {
                 elementsToDraw.forEach(el => {
                    targetCtx.save();
                    if (el.type === 'wall') {
                        targetCtx.beginPath();
                        targetCtx.moveTo(el.x1, el.y1);
                        targetCtx.lineTo(el.x2, el.y2);
                        targetCtx.strokeStyle = '#333';
                        targetCtx.lineWidth = 5;
                        targetCtx.stroke();
                    } else if (el.type === 'object') {
                        const img = images[el.subType];
                        if (img && img.complete) {
                            targetCtx.translate(el.x + el.width / 2, el.y + el.height / 2);
                            targetCtx.rotate(el.rotation * Math.PI / 180);
                            targetCtx.drawImage(img, -el.width / 2, -el.height / 2, el.width, el.height);
                        }
                    } else if (el.type === 'text') {
                        targetCtx.translate(el.x, el.y);
                        targetCtx.rotate(el.rotation * Math.PI / 180);
                        targetCtx.font = `${el.fontSize}px ${el.fontFamily}`;
                        targetCtx.fillStyle = '#333';
                        targetCtx.textAlign = 'left';
                        targetCtx.textBaseline = 'top';
                        targetCtx.fillText(el.text, 0, 0);
                    } else if (el.type === 'shape') {
                        targetCtx.translate(el.x + el.width / 2, el.y + el.height / 2);
                        targetCtx.rotate(el.rotation * Math.PI / 180);
                        targetCtx.strokeStyle = el.strokeColor;
                        targetCtx.fillStyle = el.fillColor;
                        targetCtx.lineWidth = 3;
                        targetCtx.beginPath();

                        switch(el.subType) {
                            case 'rectangle':
                                targetCtx.rect(-el.width/2, -el.height/2, el.width, el.height);
                                break;
                            case 'circle':
                                targetCtx.arc(0, 0, el.width / 2, 0, 2 * Math.PI);
                                break;
                            case 'triangle':
                                targetCtx.moveTo(0, -el.height / 2);
                                targetCtx.lineTo(el.width / 2, el.height / 2);
                                targetCtx.lineTo(-el.width / 2, el.height / 2);
                                targetCtx.closePath();
                                break;
                        }
                        if (el.fillColor !== 'transparent' && el.fillColor) targetCtx.fill();
                        targetCtx.stroke();
                    }

                    // Draw name for objects and shapes
                    if ((el.type === 'object' || el.type === 'shape') && el.name) {
                        targetCtx.font = `12px Montserrat`;
                        targetCtx.fillStyle = '#333';
                        targetCtx.textAlign = 'center';
                        targetCtx.textBaseline = 'top';
                        targetCtx.fillText(el.name, 0, el.height / 2 + 5);
                    }
                    targetCtx.restore();
                });
            }

            function draw() {
                ctx.save();
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.translate(state.pan.x, state.pan.y);
                ctx.scale(state.zoom, state.zoom);
                
                // Desenhar Guias de Alinhamento
                if (state.alignmentGuides.length > 0) {
                    ctx.save();
                    ctx.strokeStyle = '#38bdf8'; // light blue
                    ctx.lineWidth = 1 / state.zoom;
                    ctx.setLineDash([4 / state.zoom, 4 / state.zoom]);
                    state.alignmentGuides.forEach(guide => {
                        ctx.beginPath();
                        ctx.moveTo(guide.x1, guide.y1);
                        ctx.lineTo(guide.x2, guide.y2);
                        ctx.stroke();
                    });
                    ctx.restore();
                }

                // Desenhar Elementos
                drawScene(ctx, state.elements);

                // Desenhar Seleção
                const selectedElement = getSelectedElement();
                if (selectedElement) {
                    if (selectedElement.type === 'wall') {
                        drawWallSelection(selectedElement);
                    } else {
                        drawSelectionBox(selectedElement);
                    }
                }
                
                ctx.restore();
            }

            function drawSelectionBox(el) {
                ctx.save();
                
                let boxX, boxY, boxWidth, boxHeight, centerX, centerY;

                if (el.type === 'object' || el.type === 'shape') {
                    boxX = -el.width / 2;
                    boxY = -el.height / 2;
                    boxWidth = el.width;
                    boxHeight = el.height;
                    centerX = el.x + el.width / 2;
                    centerY = el.y + el.height / 2;
                } else if (el.type === 'text') {
                    ctx.font = `${el.fontSize}px ${el.fontFamily}`;
                    const metrics = ctx.measureText(el.text);
                    boxWidth = metrics.width;
                    boxHeight = el.fontSize;
                    boxX = 0;
                    boxY = 0;
                    centerX = el.x;
                    centerY = el.y;
                }

                ctx.translate(centerX, centerY);
                ctx.rotate(el.rotation * Math.PI / 180);

                ctx.strokeStyle = '#8bc53f';
                ctx.lineWidth = 2 / state.zoom;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // Handle de Rotação
                ctx.beginPath();
                ctx.arc(boxX + boxWidth/2, boxY - 15/state.zoom, 5/state.zoom, 0, 2 * Math.PI);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.stroke();

                // Handles de Redimensionamento (não para texto)
                if (el.type !== 'text') {
                    const handleSize = 8 / state.zoom;
                    ctx.fillStyle = '#8bc53f';
                    const handles = getResizeHandles(el);
                    Object.values(handles).forEach(h => {
                         ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
                    });
                }

                ctx.restore();
            }

            function drawWallSelection(el) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(el.x1, el.y1);
                ctx.lineTo(el.x2, el.y2);
                ctx.strokeStyle = '#8bc53f';
                ctx.lineWidth = 7 / state.zoom;
                ctx.stroke();

                const handleSize = 8 / state.zoom;
                ctx.fillStyle = '#8bc53f';
                ctx.fillRect(el.x1 - handleSize / 2, el.y1 - handleSize / 2, handleSize, handleSize);
                ctx.fillRect(el.x2 - handleSize / 2, el.y2 - handleSize / 2, handleSize, handleSize);
                ctx.restore();
            }


            // --- LÓGICA DA APLICAÇÃO ---
            function initialize() {
                setCanvasSize();
                addEventListeners();
                updateActiveToolButton();
                updateZoomDisplay();
                saveState();
                draw();
            }

            function setCanvasSize() {
                const containerWidth = canvasContainer.clientWidth - 40;
                const containerHeight = canvasContainer.clientHeight - 40;
                let canvasWidth, canvasHeight;

                const ratio = state.orientation === 'portrait' ? 210 / 297 : 297 / 210;

                if (containerWidth / containerHeight > ratio) {
                    canvasHeight = containerHeight;
                    canvasWidth = canvasHeight * ratio;
                } else {
                    canvasWidth = containerWidth;
                    canvasHeight = canvasWidth / ratio;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                draw();
            }
            
            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return { 
                    x: (clientX - rect.left - state.pan.x) / state.zoom, 
                    y: (clientY - rect.top - state.pan.y) / state.zoom 
                };
            }

            function getSelectedElement() {
                return state.elements.find(el => el.id === state.selectedElementId) || null;
            }
            
            function getKeyPoints(element, selfId) {
                const points = [];
                if (element.id === selfId) return points;

                if (element.type === 'wall') {
                    points.push({ x: element.x1, y: element.y1 });
                    points.push({ x: element.x2, y: element.y2 });
                    points.push({ x: (element.x1 + element.x2) / 2, y: (element.y1 + element.y2) / 2 });
                } else if ((element.type === 'object' || element.type === 'shape') && !element.wallId) {
                    const { x, y, width, height } = element;
                    points.push({ x: x, y: y }); // top-left
                    points.push({ x: x + width, y: y }); // top-right
                    points.push({ x: x, y: y + height }); // bottom-left
                    points.push({ x: x + width, y: y + height }); // bottom-right
                    points.push({ x: x + width / 2, y: y + height / 2}); // center
                }
                return points;
            }


            function distToSegment(p, v, w) {
                const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
                if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const closestPoint = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
                return Math.sqrt((p.x - closestPoint.x)**2 + (p.y - closestPoint.y)**2);
            }
            
            function isPointInTriangle(p, p0, p1, p2) {
                const dX = p.x - p2.x;
                const dY = p.y - p2.y;
                const dX21 = p2.x - p1.x;
                const dY12 = p1.y - p2.y;
                const D = dY12 * (p0.x - p2.x) + dX21 * (p0.y - p2.y);
                const s = dY12 * dX + dX21 * dY;
                const t = (p2.y - p0.y) * dX + (p0.x - p2.x) * dY;
                if (D < 0) return s <= 0 && t <= 0 && s + t >= D;
                return s >= 0 && t >= 0 && s + t <= D;
            }

            function getElementAtPos(x, y) {
                for (let i = state.elements.length - 1; i >= 0; i--) {
                    const el = state.elements[i];
                    
                    const centerX = (el.type === 'text') ? el.x : el.x + el.width/2;
                    const centerY = (el.type === 'text') ? el.y : el.y + el.height/2;

                    const dx = x - centerX;
                    const dy = y - centerY;
                    const angle = -el.rotation * Math.PI / 180;
                    const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
                    const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);

                    if (el.type === 'object' || (el.type === 'shape' && el.subType === 'rectangle')) {
                        if (rotatedX > -el.width / 2 && rotatedX < el.width / 2 && rotatedY > -el.height / 2 && rotatedY < el.height / 2) {
                            return el;
                        }
                    } else if (el.type === 'shape' && el.subType === 'circle') {
                        if (Math.sqrt(rotatedX**2 + rotatedY**2) < el.width / 2) {
                            return el;
                        }
                    } else if (el.type === 'shape' && el.subType === 'triangle') {
                        const p = {x: rotatedX, y: rotatedY};
                        const p0 = {x: 0, y: -el.height / 2};
                        const p1 = {x: el.width / 2, y: el.height / 2};
                        const p2 = {x: -el.width / 2, y: el.height / 2};
                        if (isPointInTriangle(p, p0, p1, p2)) return el;

                    } else if (el.type === 'text') {
                        ctx.font = `${el.fontSize}px ${el.fontFamily}`;
                        const metrics = ctx.measureText(el.text);
                        if (rotatedX > 0 && rotatedX < metrics.width && rotatedY > 0 && rotatedY < el.fontSize) {
                           return el;
                        }
                    } else if (el.type === 'wall') {
                        if (distToSegment({x, y}, {x: el.x1, y: el.y1}, {x: el.x2, y: el.y2}) < 5 / state.zoom) return el;
                    }
                }
                return null;
            }
            
            function getResizeHandles(el) {
                const hw = el.width / 2;
                const hh = el.height / 2;
                return {
                    'top-left': { x: -hw, y: -hh, cursor: 'nwse-resize' },
                    'top-right': { x: hw, y: -hh, cursor: 'nesw-resize' },
                    'bottom-left': { x: -hw, y: hh, cursor: 'nesw-resize' },
                    'bottom-right': { x: hw, y: hh, cursor: 'nwse-resize' }
                };
            }
            
            function getHandleAtPos(el, x, y) {
                 const handleHitboxSize = 8 / state.zoom;
                 if (el.type === 'wall') {
                    if (Math.sqrt((x - el.x1)**2 + (y - el.y1)**2) < handleHitboxSize) return 'start';
                    if (Math.sqrt((x - el.x2)**2 + (y - el.y2)**2) < handleHitboxSize) return 'end';
                    return null;
                }
                
                let centerX = el.type === 'text' ? el.x : el.x + el.width / 2;
                let centerY = el.type === 'text' ? el.y : el.y + el.height / 2;
                
                let boxHeight = el.type === 'text' ? el.fontSize : el.height;
                let boxWidth;
                if (el.type === 'text') {
                    ctx.font = `${el.fontSize}px ${el.fontFamily}`;
                    boxWidth = ctx.measureText(el.text).width;
                } else {
                    boxWidth = el.width;
                }
                

                const dx = x - centerX;
                const dy = y - centerY;
                const angle = -el.rotation * Math.PI / 180;
                const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
                const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);

                // Rotation handle
                const rotHandleY = (el.type === 'text' ? 0 : -boxHeight / 2) - 15/state.zoom;
                const rotHandleX = (el.type === 'text' ? boxWidth/2 : boxWidth/2) - boxWidth/2;
                if (Math.sqrt((rotatedX - rotHandleX)**2 + (rotatedY - rotHandleY)**2) < handleHitboxSize) return 'rotate';
                 
                if (el.type !== 'text') {
                    const handles = getResizeHandles(el);
                    for (const [key, handle] of Object.entries(handles)) {
                        if (Math.abs(rotatedX - handle.x) < handleHitboxSize / 2 && Math.abs(rotatedY - handle.y) < handleHitboxSize / 2) {
                            return key;
                        }
                    }
                }
                return null;
            }

            // --- EVENT LISTENERS ---
            function addEventListeners() {
                window.addEventListener('resize', setCanvasSize);
                // Mouse events
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
                canvas.addEventListener('dblclick', onDblClick);
                // Touch events
                canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onMouseDown(e); }, { passive: false });
                canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove(e); }, { passive: false });
                canvas.addEventListener('touchend', (e) => { e.preventDefault(); onMouseUp(e); }, { passive: false });
                canvas.addEventListener('touchcancel', (e) => { e.preventDefault(); onMouseUp(e); }, { passive: false });

                document.addEventListener('keydown', onKeyDown);

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        state.activeTool = 'select'; // default
                        if (btn.id === 'wallTool') state.activeTool = 'wall';
                        if (btn.id === 'textTool') state.activeTool = 'text';
                        if (btn.classList.contains('object-btn')) {
                            state.activeTool = 'add_object';
                            state.objectToAdd = btn.dataset.type;
                        }
                        if (btn.classList.contains('shape-btn')) {
                            state.activeTool = 'shape';
                            state.shapeToAdd = btn.dataset.type;
                        }
                        updateActiveToolButton(btn);
                    });
                });
                
                document.getElementById('deleteBtn').addEventListener('click', deleteSelected);
                document.getElementById('duplicateBtn').addEventListener('click', duplicateSelected);
                document.getElementById('undoBtn').addEventListener('click', undo);
                document.getElementById('redoBtn').addEventListener('click', redo);
                document.getElementById('projectName').addEventListener('change', e => state.projectName = e.target.value);
                document.getElementById('portraitBtn').addEventListener('click', () => changeOrientation('portrait'));
                document.getElementById('landscapeBtn').addEventListener('click', () => changeOrientation('landscape'));
                document.getElementById('downloadPdfBtn').addEventListener('click', downloadPDF);

                // Zoom controls
                document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
                document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
                document.getElementById('fitToScreenBtn').addEventListener('click', fitToScreen);

                // Text controls
                document.getElementById('fontFamilySelect').addEventListener('change', (e) => updateSelectedElement({ fontFamily: e.target.value }));
                document.getElementById('fontSizeInput').addEventListener('change', (e) => updateSelectedElement({ fontSize: parseInt(e.target.value, 10) }));
                
                // Name control
                document.getElementById('objectNameInput').addEventListener('input', (e) => updateSelectedElement({ name: e.target.value }));


                // Shape controls
                const strokeColorPicker = document.getElementById('strokeColorPicker');
                const fillColorPicker = document.getElementById('fillColorPicker');
                strokeColorPicker.addEventListener('input', (e) => updateSelectedElement({ strokeColor: e.target.value }));
                fillColorPicker.addEventListener('input', (e) => updateSelectedElement({ fillColor: e.target.value }));
            }

            let dragAction = { type: null, element: null, handle: null, startPos: null, originalElement: null };

            function onMouseDown(e) {
                state.isDrawing = true;
                const mousePos = getEventPos(e);
                state.startPoint = mousePos;

                if (e.ctrlKey) { // Pan with Ctrl+Click/Drag
                     state.pan.active = true;
                     state.pan.start = { x: e.clientX, y: e.clientY };
                     canvas.style.cursor = 'grabbing';
                     return;
                }
                
                if (state.activeTool === 'select') {
                    const selected = getSelectedElement();
                    if (selected) {
                        const handle = getHandleAtPos(selected, mousePos.x, mousePos.y);
                        if (handle) {
                             dragAction = { type: handle, element: selected, handle, startPos: mousePos, originalElement: JSON.parse(JSON.stringify(selected)) };
                             return;
                        }
                    }

                    const element = getElementAtPos(mousePos.x, mousePos.y);
                    state.selectedElementId = element ? element.id : null;
                    if(element) {
                        dragAction = { type: 'move', element, startPos: mousePos, originalElement: JSON.parse(JSON.stringify(element)) };
                    }
                    toggleControls(getSelectedElement());
                } else if (state.activeTool === 'wall') {
                    const wall = { id: Date.now(), type: 'wall', x1: mousePos.x, y1: mousePos.y, x2: mousePos.x, y2: mousePos.y };
                    state.elements.push(wall);
                    state.selectedElementId = wall.id;
                } else if (state.activeTool === 'add_object') {
                    const object = { id: Date.now(), type: 'object', subType: state.objectToAdd, x: mousePos.x - 25, y: mousePos.y - 25, width: 50, height: 50, rotation: 0, name: '' };
                    state.elements.push(object);
                    state.activeTool = 'select'; state.selectedElementId = object.id;
                    updateActiveToolButton();
                    toggleControls(object);
                    saveState();
                } else if (state.activeTool === 'text') {
                    const text = { id: Date.now(), type: 'text', text: 'Novo Texto', x: mousePos.x, y: mousePos.y, fontSize: 16, fontFamily: 'Montserrat', rotation: 0 };
                    state.elements.push(text);
                    state.activeTool = 'select'; state.selectedElementId = text.id;
                    updateActiveToolButton();
                    toggleControls(text);
                    saveState();
                } else if (state.activeTool === 'shape') {
                    const shape = { id: Date.now(), type: 'shape', subType: state.shapeToAdd, x: mousePos.x, y: mousePos.y, width: 0, height: 0, rotation: 0, strokeColor: '#333333', fillColor: 'transparent', name: ''};
                    state.elements.push(shape);
                    state.selectedElementId = shape.id;
                    dragAction = { type: 'create', element: shape, startPos: mousePos, originalElement: JSON.parse(JSON.stringify(shape)) };
                }
                draw();
            }

            function onMouseMove(e) {
                const mousePos = getEventPos(e);
                
                if (state.pan.active) {
                    const currentPos = e.touches ? e.touches[0] : e;
                    const dx = currentPos.clientX - state.pan.start.x; 
                    const dy = currentPos.clientY - state.pan.start.y;
                    state.pan.x += dx; 
                    state.pan.y += dy;
                    state.pan.start = { x: currentPos.clientX, y: currentPos.clientY };
                    draw(); return;
                }
                
                if (!state.isDrawing) {
                    let cursor = (state.activeTool === 'wall' || state.activeTool === 'text' || state.activeTool === 'shape') ? 'crosshair' : 'default';
                    if (state.activeTool === 'select') {
                        cursor = 'grab';
                        const element = getElementAtPos(mousePos.x, mousePos.y);
                        if(element) cursor = 'pointer';
                        const selected = getSelectedElement();
                        if(selected) {
                            const handle = getHandleAtPos(selected, mousePos.x, mousePos.y);
                            if (handle) {
                                if(handle === 'rotate') cursor = 'url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'currentColor\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpath d=\'M23 4v6h-6\'/%3e%3cpath d=\'M20.49 15a9 9 0 1 1-2.12-9.36L23 10\'/%3e%3c/svg%3e") 12 12, auto';
                                else if (selected.type !== 'text' && selected.type !== 'wall') cursor = getResizeHandles(selected)[handle]?.cursor || cursor;
                                else if (selected.type === 'wall') cursor = 'move';
                            }
                        }
                    }
                    canvas.style.cursor = cursor; return;
                }

                if (dragAction.type === 'create' && dragAction.element.type === 'shape') {
                    const shape = dragAction.element;
                    shape.width = Math.abs(mousePos.x - state.startPoint.x);
                    shape.height = Math.abs(mousePos.y - state.startPoint.y);
                    shape.x = Math.min(mousePos.x, state.startPoint.x);
                    shape.y = Math.min(mousePos.y, state.startPoint.y);
                    if (shape.subType === 'circle') {
                        shape.width = Math.max(shape.width, shape.height);
                        shape.height = shape.width;
                    }

                } else if (state.activeTool === 'wall' && getSelectedElement()?.type === 'wall') {
                    const wall = getSelectedElement();
                    let finalX = mousePos.x;
                    let finalY = mousePos.y;

                    state.alignmentGuides = [];
                    const snapThreshold = 10 / state.zoom;

                    let bestSnapPoint = { x: finalX, y: finalY };
                    let minSnapDist = snapThreshold;

                    for (const el of state.elements) {
                        if (el.id === wall.id) continue;
                        for (const p of getKeyPoints(el, wall.id)) {
                            const dist = Math.sqrt(Math.pow(mousePos.x - p.x, 2) + Math.pow(mousePos.y - p.y, 2));
                            if (dist < minSnapDist) {
                                minSnapDist = dist;
                                bestSnapPoint = { x: p.x, y: p.y };
                            }
                        }
                    }
                    finalX = bestSnapPoint.x;
                    finalY = bestSnapPoint.y;
                    
                    if (minSnapDist < snapThreshold) {
                        state.alignmentGuides.push({x1: finalX, y1: finalY - 10000, x2: finalX, y2: finalY + 10000});
                        state.alignmentGuides.push({x1: finalX - 10000, y1: finalY, x2: finalX + 10000, y2: finalY});
                    }
                    
                    const totalDx = Math.abs(finalX - wall.x1);
                    const totalDy = Math.abs(finalY - wall.y1);

                    if (totalDx > totalDy) {
                        wall.x2 = finalX;
                        wall.y2 = wall.y1;
                    } else {
                        wall.x2 = wall.x1;
                        wall.y2 = finalY;
                    }
                } else if (state.activeTool === 'select' && dragAction.element) {
                    const dx = mousePos.x - dragAction.startPos.x; const dy = mousePos.y - dragAction.startPos.y;
                    const el = dragAction.element; const orig = dragAction.originalElement;

                    if (dragAction.type === 'move') {
                        if (el.type === 'wall') {
                           el.x1 = orig.x1 + dx; el.y1 = orig.y1 + dy;
                           el.x2 = orig.x2 + dx; el.y2 = orig.y2 + dy;
                        } else {
                           let finalX = orig.x + dx;
                           let finalY = orig.y + dy;
                           
                           state.alignmentGuides = [];
                           const snapThreshold = 5 / state.zoom;
                           const movingPoints = getKeyPoints(el, null);

                           for (const otherEl of state.elements) {
                               if (otherEl.id === el.id) continue;
                               for (const p of getKeyPoints(otherEl, el.id)) {
                                   for (const mp of movingPoints) {
                                        const originalOffsetX = mp.x - orig.x;
                                        const originalOffsetY = mp.y - orig.y;
                                        
                                        if (Math.abs((finalX + originalOffsetX) - p.x) < snapThreshold) {
                                            finalX = p.x - originalOffsetX;
                                            state.alignmentGuides.push({x1: p.x, y1: p.y, x2: p.x, y2: finalY + originalOffsetY});
                                        }
                                        if (Math.abs((finalY + originalOffsetY) - p.y) < snapThreshold) {
                                            finalY = p.y - originalOffsetY;
                                            state.alignmentGuides.push({x1: p.x, y1: p.y, x2: finalX + originalOffsetX, y2: p.y});
                                        }
                                   }
                               }
                           }
                           el.x = finalX;
                           el.y = finalY;
                        }
                    } else if (dragAction.type === 'rotate') {
                        let centerX = el.type === 'text' ? orig.x : orig.x + orig.width / 2;
                        let centerY = el.type === 'text' ? orig.y : orig.y + orig.height / 2;
                        const startAngle = Math.atan2(dragAction.startPos.y - centerY, dragAction.startPos.x - centerX);
                        const currentAngle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX);
                        el.rotation = orig.rotation + (currentAngle - startAngle) * 180 / Math.PI;
                    } else if (dragAction.type === 'start' || dragAction.type === 'end') {
                        let mouseSnapPoint = {x: mousePos.x, y: mousePos.y};
                        state.alignmentGuides = [];
                        const snapThreshold = 10 / state.zoom;
                        let bestSnapPoint = { ...mouseSnapPoint };
                        let minSnapDist = snapThreshold;

                        for (const otherEl of state.elements) {
                           if (otherEl.id === el.id) continue;
                           for (const p of getKeyPoints(otherEl, el.id)) {
                               const dist = Math.sqrt(Math.pow(mousePos.x - p.x, 2) + Math.pow(mousePos.y - p.y, 2));
                               if (dist < minSnapDist) {
                                   minSnapDist = dist;
                                   bestSnapPoint = { x: p.x, y: p.y };
                               }
                           }
                        }
                        mouseSnapPoint = bestSnapPoint;
                        if (minSnapDist < snapThreshold) {
                             state.alignmentGuides.push({x1: mouseSnapPoint.x, y1: mouseSnapPoint.y - 10000, x2: mouseSnapPoint.x, y2: mouseSnapPoint.y + 10000});
                             state.alignmentGuides.push({x1: mouseSnapPoint.x - 10000, y1: mouseSnapPoint.y, x2: mouseSnapPoint.x + 10000, y2: mouseSnapPoint.y});
                        }

                        if (dragAction.type === 'start') {
                            const fixedEnd = { x: orig.x2, y: orig.y2 };
                            const dx = Math.abs(mouseSnapPoint.x - fixedEnd.x);
                            const dy = Math.abs(mouseSnapPoint.y - fixedEnd.y);
                            if (dx > dy) {
                                el.x1 = mouseSnapPoint.x;
                                el.y1 = fixedEnd.y;
                            } else {
                                el.x1 = fixedEnd.x;
                                el.y1 = mouseSnapPoint.y;
                            }
                        } else { // 'end' handle
                            const fixedEnd = { x: orig.x1, y: orig.y1 };
                            const dx = Math.abs(mouseSnapPoint.x - fixedEnd.x);
                            const dy = Math.abs(mouseSnapPoint.y - fixedEnd.y);
                            if (dx > dy) {
                                el.x2 = mouseSnapPoint.x;
                                el.y2 = fixedEnd.y;
                            } else {
                                el.x2 = fixedEnd.x;
                                el.y2 = mouseSnapPoint.y;
                            }
                        }
                    } else if (el.type === 'object' || el.type === 'shape') { // Resize
                        if (dragAction.handle.includes('right')) el.width = Math.max(10, orig.width + dx);
                        if (dragAction.handle.includes('left')) {
                            el.width = Math.max(10, orig.width - dx); el.x = orig.x + dx;
                        }
                        if (dragAction.handle.includes('bottom')) el.height = Math.max(10, orig.height + dy);
                        if (dragAction.handle.includes('top')) {
                            el.height = Math.max(10, orig.height - dy); el.y = orig.y + dy;
                        }
                         if (el.subType === 'circle') {
                            el.height = el.width;
                        }
                    }
                }
                draw();
            }

            function onMouseUp(e) {
                if (dragAction.type) { // Only save state if an action occurred
                    saveState();
                }
                if (state.activeTool === 'wall' || state.activeTool === 'shape') {
                    state.activeTool = 'select'; updateActiveToolButton();
                }
                state.isDrawing = false; 
                state.pan.active = false;
                dragAction = { type: null, element: null, handle: null, startPos: null, originalElement: null };
                canvas.style.cursor = state.activeTool === 'select' ? 'grab' : 'crosshair';
                state.alignmentGuides = []; // Clear guides on mouse up
                draw();
            }

            function onDblClick(e) {
                const mousePos = getEventPos(e);
                const element = getElementAtPos(mousePos.x, mousePos.y);
                if (element && element.type === 'text') {
                    editText(element);
                }
            }
            
            function onKeyDown(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    undo();
                } else if (e.ctrlKey && e.key.toLowerCase() === 'y') {
                    e.preventDefault();
                    redo();
                }

                if (e.ctrlKey && e.key.toLowerCase() === 'd') {
                    e.preventDefault();
                    duplicateSelected();
                }
                if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
                if (e.key.toLowerCase() === 'v') { state.activeTool = 'select'; updateActiveToolButton(); } 
                else if (e.key.toLowerCase() === 'w') { state.activeTool = 'wall'; updateActiveToolButton(); }
                else if (e.key.toLowerCase() === 't') { state.activeTool = 'text'; updateActiveToolButton(); }

                const selectedElement = getSelectedElement();
                if (!selectedElement) return;

                const moveAmount = e.shiftKey ? 10 : 2; // Mover mais rápido com Shift
                let moved = false;

                switch(e.key) {
                    case 'ArrowUp':
                        if (selectedElement.type === 'wall') {
                            selectedElement.y1 -= moveAmount;
                            selectedElement.y2 -= moveAmount;
                        } else {
                            selectedElement.y -= moveAmount;
                        }
                        moved = true;
                        break;
                    case 'ArrowDown':
                        if (selectedElement.type === 'wall') {
                            selectedElement.y1 += moveAmount;
                            selectedElement.y2 += moveAmount;
                        } else {
                            selectedElement.y += moveAmount;
                        }
                        moved = true;
                        break;
                    case 'ArrowLeft':
                        if (selectedElement.type === 'wall') {
                            selectedElement.x1 -= moveAmount;
                            selectedElement.x2 -= moveAmount;
                        } else {
                            selectedElement.x -= moveAmount;
                        }
                        moved = true;
                        break;
                    case 'ArrowRight':
                        if (selectedElement.type === 'wall') {
                            selectedElement.x1 += moveAmount;
                            selectedElement.x2 += moveAmount;
                        } else {
                            selectedElement.x += moveAmount;
                        }
                        moved = true;
                        break;
                }

                if (moved) {
                    e.preventDefault();
                    saveState();
                    draw();
                }
            }

            // --- AÇÕES ---
             function updateZoomDisplay() {
                zoomDisplay.textContent = `${Math.round(state.zoom * 100)}%`;
            }

            function zoomIn() {
                state.zoom = Math.min(4, state.zoom + 0.25); // Max 400%
                updateZoomDisplay();
                draw();
            }

            function zoomOut() {
                state.zoom = Math.max(0.25, state.zoom - 0.25); // Min 25%
                updateZoomDisplay();
                draw();
            }
            
            function fitToScreen() {
                state.zoom = 1;
                state.pan = { x: 0, y: 0, active: false, start: {x: 0, y: 0} };
                updateZoomDisplay();
                draw();
            }

            function deleteSelected() {
                if (state.selectedElementId) {
                    state.elements = state.elements.filter(el => el.id !== state.selectedElementId);
                    toggleControls(null);
                    state.selectedElementId = null;
                    saveState();
                    draw();
                }
            }

            function duplicateSelected() {
                const selected = getSelectedElement();
                if (selected && selected.type !== 'wall') {
                    const newElement = JSON.parse(JSON.stringify(selected));
                    newElement.id = Date.now();
                    newElement.x += 20;
                    newElement.y += 20;
                    state.elements.push(newElement);
                    state.selectedElementId = newElement.id;
                    saveState();
                    draw();
                }
            }

            function editText(element) {
                const textarea = document.createElement('textarea');
                document.body.appendChild(textarea);
                
                const canvasRect = canvas.getBoundingClientRect();
                
                textarea.value = element.text;
                textarea.style.position = 'absolute';
                textarea.style.left = `${canvasRect.left + element.x * state.zoom + state.pan.x}px`;
                textarea.style.top = `${canvasRect.top + element.y * state.zoom + state.pan.y}px`;
                textarea.style.fontFamily = element.fontFamily;
                textarea.style.fontSize = `${element.fontSize * state.zoom}px`;
                textarea.style.border = '1px solid #8bc53f';
                textarea.style.outline = 'none';
                textarea.style.zIndex = '100';
                textarea.style.transformOrigin = 'top left';
                textarea.style.transform = `rotate(${element.rotation}deg)`;
                textarea.style.lineHeight = '1.1';
                
                textarea.focus();
                textarea.select();

                const onFinish = () => {
                    element.text = textarea.value;
                    document.body.removeChild(textarea);
                    saveState();
                    draw();
                };
                
                textarea.addEventListener('blur', onFinish);
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        onFinish();
                    }
                });
            }

            function toggleControls(element) {
                const textControls = document.getElementById('textControls');
                const shapeControls = document.getElementById('shapeControls');
                const nameControls = document.getElementById('nameControls');
                
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
                nameControls.style.display = 'none';
                
                if (element?.type === 'text') {
                    textControls.style.display = 'flex';
                    document.getElementById('fontFamilySelect').value = element.fontFamily;
                    document.getElementById('fontSizeInput').value = element.fontSize;
                } else if (element?.type === 'shape') {
                    shapeControls.style.display = 'flex';
                    nameControls.style.display = 'flex';
                    document.getElementById('strokeColorPicker').value = element.strokeColor;
                    document.getElementById('strokeColorPreview').style.backgroundColor = element.strokeColor;
                    document.getElementById('fillColorPicker').value = element.fillColor;
                    document.getElementById('fillColorPreview').style.backgroundColor = element.fillColor;
                    document.getElementById('objectNameInput').value = element.name || '';
                } else if (element?.type === 'object') {
                    nameControls.style.display = 'flex';
                    document.getElementById('objectNameInput').value = element.name || '';
                }
            }

            function updateSelectedElement(props) {
                const el = getSelectedElement();
                if (el) {
                    Object.assign(el, props);
                    if (props.strokeColor) document.getElementById('strokeColorPreview').style.backgroundColor = props.strokeColor;
                    if (props.fillColor) document.getElementById('fillColorPreview').style.backgroundColor = props.fillColor;
                    saveState();
                    draw();
                }
            }
            
            function changeOrientation(orientation) {
                state.orientation = orientation;
                const isPortrait = orientation === 'portrait';
                document.getElementById('portraitBtn').classList.toggle('active', isPortrait);
                document.getElementById('portraitBtn').classList.toggle('bg-gray-700', !isPortrait);
                document.getElementById('landscapeBtn').classList.toggle('active', !isPortrait);
                document.getElementById('landscapeBtn').classList.toggle('bg-gray-700', isPortrait);
                setCanvasSize();
            }
            
            function updateActiveToolButton(activeBtn) {
                document.querySelectorAll('.tool-btn').forEach(b => {
                    b.classList.remove('active');
                     if(b.id === 'portraitBtn' && state.orientation === 'landscape') b.classList.add('bg-gray-700');
                     if(b.id === 'landscapeBtn' && state.orientation === 'portrait') b.classList.add('bg-gray-700');
                });
                if (activeBtn) {
                    activeBtn.classList.add('active');
                } else {
                    const selectTool = document.getElementById('selectTool');
                    if (selectTool) selectTool.classList.add('active');
                }
            }
            
            let notificationTimeout;
            function showNotification(message, isError = true) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.style.backgroundColor = isError ? '#ef4444' : '#22c55e'; // red or green
                notification.style.transform = 'translateX(0)';
                
                clearTimeout(notificationTimeout);
                notificationTimeout = setTimeout(() => {
                    notification.style.transform = 'translateX(120%)';
                }, 3000);
            }

            // --- HISTORY (UNDO/REDO) FUNCTIONS ---
            function saveState() {
                // Clear any future states if we've undone and then made a new change
                state.history.splice(state.historyIndex + 1);
                
                // Push a deep copy of the current elements
                state.history.push(JSON.parse(JSON.stringify(state.elements)));

                // Limit history to the last 10 states + initial state
                if (state.history.length > 11) {
                    state.history.shift();
                }
                
                state.historyIndex = state.history.length - 1;
                updateUndoRedoButtons();
            }

            function undo() {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    state.elements = JSON.parse(JSON.stringify(state.history[state.historyIndex]));
                    state.selectedElementId = null; // Deselect on undo
                    toggleControls(null);
                    updateUndoRedoButtons();
                    draw();
                }
            }

            function redo() {
                if (state.historyIndex < state.history.length - 1) {
                    state.historyIndex++;
                    state.elements = JSON.parse(JSON.stringify(state.history[state.historyIndex]));
                    state.selectedElementId = null; // Deselect on redo
                    toggleControls(null);
                    updateUndoRedoButtons();
                    draw();
                }
            }
            
            function updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                undoBtn.disabled = state.historyIndex <= 0;
                redoBtn.disabled = state.historyIndex >= state.history.length - 1;
            }

            function downloadPDF() {
                const originalId = state.selectedElementId;
                state.selectedElementId = null;
                draw();
                
                setTimeout(() => {
                    try {
                        if (state.elements.length === 0) {
                            showNotification("O projeto está vazio."); return;
                        }
                        if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                            showNotification("Erro: A biblioteca jsPDF não foi carregada."); return;
                        }
                        const { jsPDF } = window.jspdf;
                        const objectTypesInUse = [...new Set(state.elements.filter(el => el.type === 'object').map(el => el.subType))];
                        
                        const objectCounts = {};
                        state.elements.forEach(el => { if (el.type === 'object') { objectCounts[el.subType] = (objectCounts[el.subType] || 0) + 1; }});

                        // Helper to get all corner points of a rotated element
                        function getElementCorners(el) {
                            if (el.type === 'wall') {
                                return [{x: el.x1, y: el.y1}, {x: el.x2, y: el.y2}];
                            }

                            let { x, y, rotation } = el;
                            let width, height;

                            if (el.type === 'text') {
                                const currentFont = ctx.font;
                                ctx.font = `${el.fontSize}px ${el.fontFamily}`;
                                width = ctx.measureText(el.text).width;
                                height = el.fontSize;
                                ctx.font = currentFont;
                            } else {
                                width = el.width;
                                height = el.height;
                            }
                            
                            const cx = x + width / 2;
                            const cy = y + height / 2;
                            const angle = rotation * Math.PI / 180;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);

                            const corners = [
                                { x: x, y: y }, { x: x + width, y: y },
                                { x: x + width, y: y + height }, { x: x, y: y + height }
                            ];

                            const rotatedCorners = corners.map(p => ({
                                x: (p.x - cx) * cos - (p.y - cy) * sin + cx,
                                y: (p.x - cx) * sin + (p.y - cy) * cos + cy
                            }));

                            if (el.name && (el.type === 'object' || el.type === 'shape')) {
                                const nameOffsetY = height / 2 + 15;
                                const namePoint = { x: 0, y: nameOffsetY };
                                const rotatedNamePoint = {
                                    x: namePoint.x * cos - namePoint.y * sin + cx,
                                    y: namePoint.x * sin + namePoint.y * cos + cy,
                                };
                                const nameWidth = ctx.measureText(el.name).width / 2;
                                rotatedCorners.push({x: rotatedNamePoint.x - nameWidth, y: rotatedNamePoint.y - 12});
                                rotatedCorners.push({x: rotatedNamePoint.x + nameWidth, y: rotatedNamePoint.y});
                            }
                            return rotatedCorners;
                        }

                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        state.elements.forEach(el => { getElementCorners(el).forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); });

                        if (maxX === -Infinity) { showNotification("O projeto está vazio."); return; }

                        const pdf = new jsPDF({ orientation: state.orientation, unit: 'mm', format: 'a4' });
                        const pdfWidthMM = pdf.internal.pageSize.getWidth();
                        const pdfHeightMM = pdf.internal.pageSize.getHeight();
                        const marginMM = 10;
                        const projectNameHeightMM = 7;
                        const legendTitleHeightMM = objectTypesInUse.length > 0 ? 6 : 0;
                        const legendItemHeightMM = 7;
                        const legendContentHeightMM = legendTitleHeightMM + (objectTypesInUse.length * legendItemHeightMM);
                        const headerPaddingMM = 5;
                        const headerHeightMM = projectNameHeightMM + legendContentHeightMM + headerPaddingMM;
                        const drawingStartY_MM = marginMM + headerHeightMM;
                        const drawingWidthMM = pdfWidthMM - (marginMM * 2);
                        const drawingHeightMM = pdfHeightMM - drawingStartY_MM - marginMM;
                        
                        pdf.setFontSize(14);
                        pdf.setFont('helvetica', 'bold');
                        pdf.text(state.projectName, marginMM, marginMM + 5);

                        if (objectTypesInUse.length > 0) {
                            let legendY = marginMM + projectNameHeightMM + 5;
                            pdf.setFontSize(12);
                            pdf.setFont('helvetica', 'bold');
                            pdf.text("Legenda:", marginMM, legendY);
                            legendY += legendItemHeightMM;
                            pdf.setFontSize(9);
                            pdf.setFont('helvetica', 'normal');
                            const iconSizeMM = 6;
                            const legendIconCanvas = document.createElement('canvas');
                            const legendIconCtx = legendIconCanvas.getContext('2d');
                            legendIconCanvas.width = 64; legendIconCanvas.height = 64;
                            objectTypesInUse.forEach(subType => {
                                const img = images[subType];
                                const count = objectCounts[subType] || 0;
                                const title = `${objectTitles[subType] || subType} (x${count})`;
                                legendIconCtx.clearRect(0, 0, 64, 64);
                                if (img && img.complete) { legendIconCtx.drawImage(img, 0, 0, 64, 64); }
                                const iconPngDataUrl = legendIconCanvas.toDataURL('image/png');
                                pdf.addImage(iconPngDataUrl, 'PNG', marginMM, legendY, iconSizeMM, iconSizeMM);
                                pdf.text(title, marginMM + iconSizeMM + 2, legendY + iconSizeMM / 2 + 2);
                                legendY += legendItemHeightMM;
                            });
                        }

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        const padding = 50;
                        const contentWidth = (maxX - minX) + padding * 2;
                        const contentHeight = (maxY - minY) + padding * 2;
                        
                        if (!isFinite(contentWidth) || contentWidth <= 0 || !isFinite(contentHeight) || contentHeight <= 0) {
                            showNotification("Conteúdo inválido para exportação. Tente novamente.");
                            return;
                        }

                        // --- LÓGICA DE ESCALA SEGURA PARA EVITAR ERROS DE MEMÓRIA ---
                        const highResScale = 4;
                        const MAX_PIXELS = 16777216; // Limite seguro REDUZIDO (16 megapixels, e.g., 4096x4096)
                        let tempCanvasWidth = contentWidth * highResScale;
                        let tempCanvasHeight = contentHeight * highResScale;

                        if (tempCanvasWidth * tempCanvasHeight > MAX_PIXELS) {
                            const ratio = tempCanvasWidth / tempCanvasHeight;
                            tempCanvasHeight = Math.sqrt(MAX_PIXELS / ratio);
                            tempCanvasWidth = tempCanvasHeight * ratio;
                        }
                        
                        // Verificação final antes de criar o canvas
                        if (!isFinite(tempCanvasWidth) || tempCanvasWidth <= 0 || !isFinite(tempCanvasHeight) || tempCanvasHeight <= 0) {
                            showNotification("Erro ao calcular dimensões do projeto para o PDF.");
                            return;
                        }

                        tempCanvas.width = Math.round(tempCanvasWidth);
                        tempCanvas.height = Math.round(tempCanvasHeight);

                        const finalScale = tempCanvas.width / contentWidth;

                        tempCtx.fillStyle = 'white';
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        tempCtx.save();
                        tempCtx.scale(finalScale, finalScale);
                        tempCtx.translate(-minX + padding, -minY + padding);
                        drawScene(tempCtx, state.elements);
                        tempCtx.restore();
                        
                        const imgData = tempCanvas.toDataURL('image/jpeg', 0.98);

                        // --- CORREÇÃO DA PROPORÇÃO ---
                        const contentRatio = contentWidth / contentHeight;
                        const pdfDrawingRatio = drawingWidthMM / drawingHeightMM;
                        let finalImageWidthMM, finalImageHeightMM;

                        if (contentRatio > pdfDrawingRatio) {
                            // O conteúdo é mais largo que a área do PDF, então ajusta pela largura
                            finalImageWidthMM = drawingWidthMM;
                            finalImageHeightMM = drawingWidthMM / contentRatio;
                        } else {
                            // O conteúdo é mais alto ou proporcional, então ajusta pela altura
                            finalImageHeightMM = drawingHeightMM;
                            finalImageWidthMM = drawingHeightMM * contentRatio;
                        }
                        
                        // Centraliza a imagem na área de desenho
                        const offsetX_MM = marginMM + (drawingWidthMM - finalImageWidthMM) / 2;
                        const offsetY_MM = drawingStartY_MM + (drawingHeightMM - finalImageHeightMM) / 2;

                        pdf.addImage(imgData, 'JPEG', offsetX_MM, offsetY_MM, finalImageWidthMM, finalImageHeightMM, undefined, 'FAST');
                        
                        pdf.setDrawColor(180, 180, 180);
                        pdf.rect(marginMM / 2, marginMM / 2, pdfWidthMM - marginMM, pdfHeightMM - marginMM);
                        pdf.save(`${state.projectName}.pdf`);
                    } catch(error) {
                        console.error("Erro ao gerar PDF:", error);
                        showNotification(`Ocorreu um erro ao gerar o PDF. (${error.message || error})`);
                    } finally {
                        state.selectedElementId = originalId;
                        draw();
                    }
                }, 100);
            }
            initialize();
        });
    </script>
</body>
</html>

